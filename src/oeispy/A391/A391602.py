# This file is auto-generated from OEIS data.
# Please do not edit this file directly.
# OEIS sequence: A391602

""" Note: This code is an example. Because the search range is so large, it is only practical to run as multiple parallel threads, each taking a part of the search space. The parallelization is not shown here. """
from sympy import primerange
import numpy as np
from numba import njit
delta_limit, m_range = 3, 10_000_000_000_000
primes = np.array([0] + list(primerange(2, 100)))
@njit(cache=True)
def fast_po(m): # Return a fast Pidx and omega if they are small numbers
    Pidx, omega = 0, 0
    for i in range (1, 26):
        p = primes[i]
        if p > m:
            return 99999, 0
        div_hit = 1
        while m % p == 0:
            omega += div_hit
            div_hit = 0
            Pidx = i
            m //= p
            if m == 1:
                return Pidx, omega
    return 99999, 0
delta_min = [0] * delta_limit
Pidx_m, omega_m = 0, 0
for m in range(1, m_range+1):
    Pidx_p1, omega_p1 = fast_po(m+1)
    omega_product = omega_m + omega_p1
    Pidx_product = max(Pidx_m, Pidx_p1)
    Pidx_m, omega_m = Pidx_p1, omega_p1
    delta = Pidx_product - omega_product
    if delta < delta_limit:
        delta_min[delta] = m
print(f"Final m = {m:,} and minimum deltas were at m = {delta_min}")

