# This file is auto-generated from OEIS data.
# Please do not edit this file directly.
# OEIS sequence: A376446

# Function to calculate the p-adic valuation
def p_adic_valuation(n, p):
    count = 0
    while n % p == 0 and n != 0:
        n //= p
        count += 1
    return count
# Function to calculate tetration (tower of powers)
def tetration(base, height, last_digits=500):
    results = [base]
    for n in range(1, height):
        result = pow(base, results[-1], 10**last_digits)  # Only the last last_digits digits
        results.append(result)
    return results
# Function to find the first non-zero difference and compute modulo 10
def find_difference_mod_10(tetrations):
    differences = []
    for n in range(len(tetrations) - 1):
        string_n = str(tetrations[n]).zfill(500)  # Pad with zeros if needed
        string_n_plus_1 = str(tetrations[n+1]).zfill(500)
        # Find the first difference starting from the rightmost digit
        for i in range(499, -1, -1):  # From right to left
            if string_n[i] != string_n_plus_1[i]:
                difference = (int(string_n[i]) - int(string_n_plus_1[i])) % 10
                differences.append(difference)
                break
    return differences
# Function to determine the first hyperexponent based on modulo 5 congruences
def calculate_initial_exponent(a):
    mod_5 = a % 5
    if mod_5 == 1:
        valuation = p_adic_valuation(a - 1, 5)
        initial_exponent = valuation + 2
    elif mod_5 in [2, 3]:
        valuation = p_adic_valuation(a**2 + 1, 5)
        initial_exponent = valuation + 2
    elif mod_5 == 4:
        valuation = p_adic_valuation(a + 1, 5)
        initial_exponent = valuation + 2
    else:
        valuation = p_adic_valuation(a**2 - 1, 2)
        initial_exponent = valuation + 1
    return initial_exponent
# Main logic
try:
    a = int(input("Enter a positive integer greater than 1: "))
    # Check if the number ends with 0
    if a % 10 == 0:
        print(-1)
    elif a <= 1:
        raise ValueError("The number must be greater than 1.")
    else:
        # Calculate the initial exponent based on modulo 5 congruence
        initial_exponent = calculate_initial_exponent(a)
        # Generate tetrations for 30 iterations and the last 500 digits
        tetrations = tetration(a, 30, last_digits=500)
        # Find the modulo 10 differences for the 4 required iterations
        mod_10_differences = find_difference_mod_10(tetrations[initial_exponent-1:initial_exponent+4])
        # Optimization of the output
        if mod_10_differences[:2] == mod_10_differences[2:]:
            mod_10_differences = mod_10_differences[:2]
        if len(set(mod_10_differences)) == 1:
            mod_10_differences = [mod_10_differences[0]]
        # Convert the list of differences into a string without brackets or commas
        result_str = ''.join(map(str, mod_10_differences))
        # Print the optimized result
        print(f"a({a}) = {result_str}")
except Exception as e:
    print(f"ERROR!\n{e}")

