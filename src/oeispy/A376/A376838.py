# This file is auto-generated from OEIS data.
# Please do not edit this file directly.
# OEIS sequence: A376838

# Function to calculate the p-adic valuation
def p_adic_valuation(n, p):
    count = 0
    while n % p == 0 and n != 0:
        n //= p
        count += 1
    return count
# Function to calculate tetration (tower of powers)
def tetration(base, height, last_digits=50000):
    results = [base]
    for n in range(1, height):
        result = pow(base, results[-1], 10**last_digits)  # Only the last last_digits digits
        results.append(result)
    return results
# Function to find the first non-zero difference and compute modulo 10
def find_difference_mod_10(tetrations):
    differences = []
    for n in range(len(tetrations) - 1):
        string_n = str(tetrations[n]).zfill(50000)  # Pad with zeros if needed
        string_n_plus_1 = str(tetrations[n+1]).zfill(50000)
        # Find the first difference starting from the rightmost digit
        for i in range(49999, -1, -1):  # From right to left
            if string_n[i] != string_n_plus_1[i]:
                difference = (int(string_n[i]) - int(string_n_plus_1[i])) % 10
                differences.append(difference)
                break
    return differences
# Function to determine the first hyperexponent based on modulo 5 congruences
def calculate_initial_exponent(a):
    mod_5 = a % 5
    if mod_5 == 1:
        valuation = p_adic_valuation(a - 1, 5)
        initial_exponent = valuation + 2
    elif mod_5 in [2, 3]:
        valuation = p_adic_valuation(a**2 + 1, 5)
        initial_exponent = valuation + 2
    elif mod_5 == 4:
        valuation = p_adic_valuation(a + 1, 5)
        initial_exponent = valuation + 2
    else:
        valuation = p_adic_valuation(a**2 - 1, 2)
        initial_exponent = valuation + 1
    return initial_exponent
# Main logic
try:
    # Ask for the maximum value of n*10
    n = int(input("Write the maximum value of n*10: "))
    # Validate the input
    if n <= 1 or n > 1000:
        raise ValueError("Please enter a positive integer between 1 and 1000.")
    # Initialize an empty list to store the second digits of the sfasamenti
    sfasamenti_second_digits = []
    # Loop through bases 10, 20, ..., n*10
    for a in range(10, (n * 10) + 1, 10):
        # Calculate the initial exponent based on modulo 5 congruence
        initial_exponent = calculate_initial_exponent(a)
        # Generate tetrations for 30 iterations and the last 500 digits
        tetrations = tetration(a, 3, last_digits=50000)
        # Find the modulo 10 differences for the 4 required iterations
        mod_10_differences = find_difference_mod_10(tetrations[initial_exponent-1:initial_exponent+4])
        # Optimization of the output
        if mod_10_differences[:2] == mod_10_differences[2:]:
            mod_10_differences = mod_10_differences[:2]
        if len(set(mod_10_differences)) == 1:
            mod_10_differences = [mod_10_differences[0]]
        # Append the second digit of the sfasamenti (if it exists) to the list
        if len(mod_10_differences) > 1:
            sfasamenti_second_digits.append(mod_10_differences[1])
        else:
            sfasamenti_second_digits.append(mod_10_differences[0])
    # Convert the list of second digits into a string
    result_str = ', '.join(map(str, sfasamenti_second_digits))
    # Print the final output
    print(f"The values of the sfasamenti at height 2 of 10 to {n * 10} are: {result_str}")
except Exception as e:
    print(f"ERROR!\n{e}")

