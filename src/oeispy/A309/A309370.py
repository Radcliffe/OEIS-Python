# This file is auto-generated from OEIS data.
# Please do not edit this file directly.
# OEIS sequence: A309370

def Sidon(S): # check whether S[-1] is b+c-a, a<b<c in S
    if len(S) < 4: return True
    L = 1 << (d := S[-1]).bit_length()-1
    for k,c in enumerate(S[-2:1:-1], 3):
        if c < L: return True # can't write d+a as b+c
        if any(not(d & ~(b|c)) and b^c^d in S[:-j] and not(b&c&~d)
               for j,b in enumerate(S[-k:0:-1], k)): return False
    return True
def A309370(n, solution = False, debug = False):
    "If solution=True, return a solution set, else just the length."
    if not hasattr(A := A309370, 'sol'): A.sol = [[0]]
    while len(A.sol) <= n: # compute one more solution
        M = 2**len(A.sol)  # largest possible value = M-1 = (1...1)
        A.sol += [S := list(A.sol[-1])] # S = candidate for a larger sol'n
        while S == A.sol[-1]: # try to extend it to a larger solution
            L = len(S := S + [S[-1]]); increment = True
            while increment: # find next candidate of same len
                i = 1 # "negative" index of element we'll try to increment
                while i <= L:
                    if S[-i] >= M-i: i += 1 ; continue
                    if i > 1: S[-i:] = range(S[-i]+1, S[-i]+1+i)
                    else: S[-i] += 1
                    while i > 1:
                        if Sidon(S[:-i+1]): i -= 1
                        else: break # go on incrementing at i
                    else: # all smaller initial segments are Sidon
                        if Sidon(S): A.sol[-1] = S; increment = False
                        break # otherwise go on incrementing at i=1
                else: break # reached the leftmost digit: no solution
            else: # when sol'n with len = a(n) is found, you can interrupt
                if debug: print("Found sol'n of length", len(S), ":", S)
    return A.sol[n] if solution else len(A.sol[n]) # _M. F. Hasler_, Oct 02 2025

