# This file is auto-generated from OEIS data.
# Please do not edit this file directly.
# OEIS sequence: A380462

import math
from collections import deque
def is_perfect_square(n):
    return (math.isqrt(n)) ** 2 == n
def generate_all_solutions(up_to_bound):
    solutions = set()
    visited = set()
    seed = (2, 2, 2, 2)
    queue = deque([seed])
    solutions.add(seed)
    while queue:
        quad = queue.popleft()
        for ii in range(4):
            rotated = list(quad[ii:] + quad[:ii])
            x, y, z, w = rotated
            product = y * z * w
            sumsq = y**2 + z**2 + w**2
            D = product**2 - 4 * sumsq
            if D < 0 or not is_perfect_square(D):
                continue
            sqrt_D = (math.isqrt(D))
            for sign in [+1, -1]:
                x_new = (product + sign * sqrt_D)
                if x_new % 2 != 0:
                    continue
                x_new //= 2
                if not (0 < x_new < up_to_bound):
                    continue
                new_quad = [x_new, y, z, w]
                if any(val >= up_to_bound for val in new_quad):
                    continue
                new_quad_sorted = tuple(sorted(new_quad))
                if new_quad_sorted not in visited:
                    solutions.add(new_quad_sorted)
                    queue.append(tuple(new_quad))
                    visited.add(new_quad_sorted)
    return sorted(solutions)
# Compute all solutions up to e^100
max_bound = math.exp(100)
all_solutions = generate_all_solutions(max_bound)
# Precompute max entry of each solution for fast thresholding
solution_maxes = [max(sol) for sol in all_solutions]
# Generate the sequence a(n) for n = 1 to 100
a_n = []
for n in range(1, 101):
    threshold = math.exp(n)
    count = sum(1 for m in solution_maxes if m < threshold)
    a_n.append(count)
print(a_n)

