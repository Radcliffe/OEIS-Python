# This file is auto-generated from OEIS data.
# Please do not edit this file directly.
# OEIS sequence: A383190

class A383190: # use A383190(n) or a=A383190(); a[n]; print(a); for x in a: ...
    border, grid, terms = {0}, {}, []
    neighbors = (1, 1+1j, 1j, 1j-1, -1, -1-1j, -1j, 1-1j)
    def __str__(self): #"ASCII representation of (filled part of) the plane."
        X = sorted({z.real for z in self.grid}); L = len(str(len(self.terms)))+1
        return "\n".join("".join(f"{self.grid.get(x+y*1j,'')!s:{L}}" for x in X)
                         for y in sorted({z.imag for z in self.grid}, reverse=1))
    def __new__(cls, n: int | None = None) -> int | object:
        """Return a(n) or the sequence object if no n is given."""
        return super().__new__(cls) if n is None else super().__new__(cls)(n)
    def __call__(self, n: int | None = None) -> int | object:
        """Return a(n) or the sequence object if no n is given."""
        return self if n is None else self.extend(upto=n) or self.terms[n]
    def __getitem__(self, n: int | slice) -> int | list:
        return self(n) if isinstance(n, int) else [self(n) for n in
            range(*n.indices(max(len(self.terms), abs(n.stop or 0))))]
    def extend(self, upto=None):
        "Place new domino(s) on the grid, as 'close' as possible to the origin."
        while len(self.terms) <= (upto or (upto := len(self.terms))):
            self.fill(pos := min(self.border, key = self.distance))
            self.fill(self.second(pos))
    def distance(self, pos):
        "Return (abs(pos), arg(pos)), where 0 <= arg < τ = 2π."
        return abs(pos), atan2(pos.imag, pos.real) % tau
    def fill(self, pos):
        """Fill the next available number into grid[pos], increment, and
        update border = {free cells that are neighbor to a filled cell}."""
        self.grid[pos] = len(self.terms); self.border.remove(pos)
        self.border |= {pos+N for N in self.neighbors if pos+N not in self.grid}
        self.terms += [int(4*y**2-y-x if (y:=pos.imag)>=abs(x:=pos.real) else
         4*x**2-x-y if -x>=abs(y) else (4*y-3)*y+x if -y>=abs(x) else(4*x-3)*x+y)]
    def second(self,pos):
        """Find the second cell adjacent to 'pos' so that the domino is oriented
        according the rules (closest to origin but no domino side-by-side)."""
        return min((pos+dir for dir in(1, 1j, -1, -1j) if pos+dir not in self.grid
            and all(self.grid.get(p+dir, -1) != self.grid.get(p, -1) ^ 1
                    for p in (pos+1j*dir, pos-1j*dir) ) ), key = self.distance)
from math import atan2, tau
print(A383190()[:50])
print(A383190()) # displays the grid filled so far

