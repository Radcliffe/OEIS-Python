# This file is auto-generated from OEIS data.
# Please do not edit this file directly.
# OEIS sequence: A330882

from numba import njit
@njit()  # comment out for digits > 64
def LBfactors(w, digits):
  if digits <= 1: return digits
  if not (1 << (digits-1)) & w:  # if the 1st bit is not 1,
    w ^= ((1 << digits) - 1)     # then invert the string
  for i in range(digits//2, 0, -1):
    mask = (1 << i) - 1
    if (w >> (digits-i)) == (w & mask):
      digitsprime = digits - 2*i
      if digitsprime == 0:
        return 2
      else:
        middle_mask = ((1 << digitsprime) - 1)
        wprime = middle_mask & (w >> i)
        return 2 + LBfactors(wprime, digitsprime)
  return 1
@njit()  # comment out for n > 64
def a(n):
  if n <= 1: return 2**n
  maximum, maximum_count = -1, 0
  for i in range(2**(n-1)):  # only search 1st bit == 1 by symmetry
    LBfacsw = LBfactors((1<<(n-1))|i, n)
    if LBfacsw == maximum:
      maximum_count += 1
    elif LBfacsw > maximum:
      maximum = LBfacsw
      maximum_count = 1
  return 2*maximum_count     # symmetry
print([a(n) for n in range(25)]) # _Michael S. Branicky_, Dec 31 2020

